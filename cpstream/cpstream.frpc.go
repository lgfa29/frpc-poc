// Code generated by fRPC Go v0.10.0, DO NOT EDIT.
// source: cpstream.proto

package cpstream

import (
	"errors"
	"net"
	"sync"
	"context"
	"github.com/loopholelabs/polyglot/v2"

	"crypto/tls"
	"github.com/loopholelabs/frisbee-go"
	"github.com/loopholelabs/frisbee-go/pkg/packet"
	"github.com/loopholelabs/logging/types"

	"sync/atomic"
	"io"
)

var (
	ErrDecodeNil = errors.New("cannot decode into a nil root struct")
)

type ControlPlaneCommand struct {
	error error
	flags uint8

	Uuid              string
	ListInstancesCmd  *ListInstancesCommand
	CreateInstanceCmd *CreateInstanceCommand
}

func NewControlPlaneCommand() *ControlPlaneCommand {
	return &ControlPlaneCommand{
		ListInstancesCmd:  NewListInstancesCommand(),
		CreateInstanceCmd: NewCreateInstanceCommand(),
	}
}

func (x *ControlPlaneCommand) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ControlPlaneCommand) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Uuid)
		x.ListInstancesCmd.Encode(b)
		x.CreateInstanceCmd.Encode(b)
	}
}

func (x *ControlPlaneCommand) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ControlPlaneCommand) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Uuid, err = d.String()
	if err != nil {
		return err
	}
	if x.ListInstancesCmd == nil {
		x.ListInstancesCmd = NewListInstancesCommand()
	}
	err = x.ListInstancesCmd.decode(d)
	if err != nil {
		return err
	}
	if x.CreateInstanceCmd == nil {
		x.CreateInstanceCmd = NewCreateInstanceCommand()
	}
	err = x.CreateInstanceCmd.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type ListInstancesCommand struct {
	error error
	flags uint8
}

func NewListInstancesCommand() *ListInstancesCommand {
	return &ListInstancesCommand{}
}

func (x *ListInstancesCommand) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ListInstancesCommand) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
	}
}

func (x *ListInstancesCommand) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ListInstancesCommand) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	return nil
}

type CreateInstanceCommand struct {
	error error
	flags uint8

	Name    string
	Package string
}

func NewCreateInstanceCommand() *CreateInstanceCommand {
	return &CreateInstanceCommand{}
}

func (x *CreateInstanceCommand) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *CreateInstanceCommand) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Name).String(x.Package)
	}
}

func (x *CreateInstanceCommand) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *CreateInstanceCommand) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Name, err = d.String()
	if err != nil {
		return err
	}
	x.Package, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type ControlPlaneResponse struct {
	error error
	flags uint8

	Uuid               string
	Err                string
	ListInstancesResp  *ListInstancesResponse
	CreateInstanceResp *CreateInstanceResponse
}

func NewControlPlaneResponse() *ControlPlaneResponse {
	return &ControlPlaneResponse{
		ListInstancesResp:  NewListInstancesResponse(),
		CreateInstanceResp: NewCreateInstanceResponse(),
	}
}

func (x *ControlPlaneResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ControlPlaneResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Uuid).String(x.Err)
		x.ListInstancesResp.Encode(b)
		x.CreateInstanceResp.Encode(b)
	}
}

func (x *ControlPlaneResponse) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ControlPlaneResponse) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Uuid, err = d.String()
	if err != nil {
		return err
	}
	x.Err, err = d.String()
	if err != nil {
		return err
	}
	if x.ListInstancesResp == nil {
		x.ListInstancesResp = NewListInstancesResponse()
	}
	err = x.ListInstancesResp.decode(d)
	if err != nil {
		return err
	}
	if x.CreateInstanceResp == nil {
		x.CreateInstanceResp = NewCreateInstanceResponse()
	}
	err = x.CreateInstanceResp.decode(d)
	if err != nil {
		return err
	}
	return nil
}

type ListInstancesResponse struct {
	error error
	flags uint8

	Instances []string
}

func NewListInstancesResponse() *ListInstancesResponse {
	return &ListInstancesResponse{}
}

func (x *ListInstancesResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *ListInstancesResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)

		polyglot.Encoder(b).Slice(uint32(len(x.Instances)), polyglot.StringKind)
		for _, v := range x.Instances {
			polyglot.Encoder(b).String(v)
		}
	}
}

func (x *ListInstancesResponse) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *ListInstancesResponse) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	var sliceSize uint32
	sliceSize, err = d.Slice(polyglot.StringKind)
	if err != nil {
		return err
	}
	if uint32(len(x.Instances)) != sliceSize {
		x.Instances = make([]string, sliceSize)
	}
	for i := uint32(0); i < sliceSize; i++ {
		x.Instances[i], err = d.String()
		if err != nil {
			return err
		}
	}
	return nil
}

type CreateInstanceResponse struct {
	error error
	flags uint8

	Name string
}

func NewCreateInstanceResponse() *CreateInstanceResponse {
	return &CreateInstanceResponse{}
}

func (x *CreateInstanceResponse) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *CreateInstanceResponse) Encode(b *polyglot.Buffer) {
	if x == nil {
		polyglot.Encoder(b).Nil()
	} else {
		if x.error != nil {
			polyglot.Encoder(b).Error(x.error)
			return
		}
		polyglot.Encoder(b).Uint8(x.flags)
		polyglot.Encoder(b).String(x.Name)
	}
}

func (x *CreateInstanceResponse) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	return x.decode(polyglot.Decoder(b))
}

func (x *CreateInstanceResponse) decode(d *polyglot.BufferDecoder) error {
	if d.Nil() {
		return nil
	}

	var err error
	x.error, err = d.Error()
	if err == nil {
		return nil
	}
	x.flags, err = d.Uint8()
	if err != nil {
		return err
	}
	x.Name, err = d.String()
	if err != nil {
		return err
	}
	return nil
}

type ControlPlaneStream interface {
	Stream(context.Context, *StreamServer) error
}

const connectionContextKey int = 1000

func SetErrorFlag(flags uint8, error bool) uint8 {
	return flags | 0x2
}
func HasErrorFlag(flags uint8) bool {
	return flags&(1<<1) == 1
}

type RPCStreamOpen struct {
	operation uint16
}

func (x *RPCStreamOpen) Error(b *polyglot.Buffer, err error) {
	polyglot.Encoder(b).Error(err)
}

func (x *RPCStreamOpen) Encode(b *polyglot.Buffer) {
	polyglot.Encoder(b).Uint16(x.operation)
}

func (x *RPCStreamOpen) Decode(b []byte) error {
	if x == nil {
		return ErrDecodeNil
	}
	d := polyglot.Decoder(b)
	return x.decode(d)
}

func (x *RPCStreamOpen) decode(d *polyglot.BufferDecoder) error {
	var err error
	x.operation, err = d.Uint16()
	return err
}

type Server struct {
	server *frisbee.Server
	wg     sync.WaitGroup
}

func NewServer(controlPlaneStream ControlPlaneStream, tlsConfig *tls.Config, logger types.Logger) (*Server, error) {
	s := new(Server)
	table := make(frisbee.HandlerTable)

	var err error
	if tlsConfig != nil {
		s.server, err = frisbee.NewServer(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		s.server, err = frisbee.NewServer(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	s.server.SetStreamHandler(func(ctx context.Context, stream *frisbee.Stream) {
		p, err := stream.ReadPacket()
		if err != nil {
			return
		}
		open := &RPCStreamOpen{}
		err = open.Decode((*p.Content).Bytes())
		if err != nil {
			stream.Close()
			return
		}
		switch open.operation {
		case 10:
			s.createStreamServer(ctx, controlPlaneStream, stream)
		}
	})

	s.server.ConnContext = func(ctx context.Context, conn *frisbee.Async) context.Context {
		return context.WithValue(ctx, connectionContextKey, conn)
	}

	return s, nil
}

func (s *Server) SetOnClosed(f func(*frisbee.Async, error)) error {
	return s.server.SetOnClosed(f)
}

func (s *Server) SetPreWrite(f func()) error {
	return s.server.SetPreWrite(f)
}

func (s *Server) SetConcurrency(concurrency uint64) {
	s.server.SetConcurrency(concurrency)
}

func (s *Server) Start(addr string) error {
	return s.server.Start(addr)
}

func (s *Server) StartWithListener(listener net.Listener) error {
	return s.server.StartWithListener(listener)
}

func (s *Server) ServeConn(conn net.Conn) {
	s.server.ServeConn(conn)
}

func (s *Server) Shutdown() error {
	err := s.server.Shutdown()
	if err != nil {
		return err
	}
	s.wg.Wait()
	return nil
}

type StreamServer struct {
	recv func() (*ControlPlaneResponse, error)
	send func(*ControlPlaneCommand) error

	stream *frisbee.Stream
	closed *atomic.Bool
}

func (s *Server) createStreamServer(ctx context.Context, controlPlaneStream ControlPlaneStream, stream *frisbee.Stream) {
	srv := &StreamServer{
		stream: stream,
	}

	srv.recv = func() (*ControlPlaneResponse, error) {
		p, err := srv.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewControlPlaneResponse()
		err = res.Decode((*p.Content).Bytes())
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}
	srv.send = func(m *ControlPlaneCommand) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32((*p.Content).Len())
		return srv.stream.WritePacket(p)
	}

	s.wg.Add(1)
	go func() {
		err := controlPlaneStream.Stream(ctx, srv)
		if err != nil {
			res := ControlPlaneCommand{error: err}
			res.flags = SetErrorFlag(res.flags, true)
			srv.CloseAndSend(&res)
		} else {
			srv.CloseSend()
		}
		s.wg.Done()
	}()
}

func (x *StreamServer) Recv() (*ControlPlaneResponse, error) {
	return x.recv()
}

func (x *StreamServer) close() {
	x.stream.Close()
}
func (x *StreamServer) Send(m *ControlPlaneCommand) error {
	return x.send(m)
}
func (x *StreamServer) CloseSend() error {
	return x.send(&ControlPlaneCommand{error: io.EOF})
}

func (x *StreamServer) CloseChannel() <-chan struct{} {
	return x.stream.Conn().CloseChannel()
}

func (x *StreamServer) CloseAndSend(m *ControlPlaneCommand) error {
	err := x.send(m)
	if err != nil {
		return err
	}
	return x.CloseSend()
}

type subControlPlaneStreamClient struct {
	client            *frisbee.Client
	nextStreamingID   uint16
	nextStreamingIDMu sync.RWMutex
}
type Client struct {
	*frisbee.Client
	ControlPlaneStream *subControlPlaneStreamClient
}

func NewClient(tlsConfig *tls.Config, logger types.Logger) (*Client, error) {
	c := new(Client)
	table := make(frisbee.HandlerTable)

	var err error
	if tlsConfig != nil {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithTLS(tlsConfig), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	} else {
		c.Client, err = frisbee.NewClient(table, context.Background(), frisbee.WithLogger(logger))
		if err != nil {
			return nil, err
		}
	}

	c.ControlPlaneStream = new(subControlPlaneStreamClient)
	c.ControlPlaneStream.client = c.Client
	return c, nil
}

func (c *Client) Connect(addr string, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.Connect(addr, func(stream *frisbee.Stream) {})
}

func (c *Client) FromConn(conn net.Conn, streamHandler ...frisbee.NewStreamHandler) error {
	return c.Client.FromConn(conn, func(stream *frisbee.Stream) {})
}

func (c *subControlPlaneStreamClient) Stream(ctx context.Context, req *ControlPlaneResponse) (*StreamClient, error) {
	p := packet.Get()

	c.nextStreamingIDMu.Lock()
	c.nextStreamingID += 1
	id := c.nextStreamingID
	c.nextStreamingIDMu.Unlock()

	open := &RPCStreamOpen{operation: 10}

	open.Encode(p.Content)
	p.Metadata.ContentLength = uint32((*p.Content).Len())

	fStream := c.client.Stream(id)
	fStream.WritePacket(p)

	if req != nil {
		p2 := packet.Get()
		req.Encode(p2.Content)
		p2.Metadata.ContentLength = uint32((*p2.Content).Len())
		fStream.WritePacket(p2)
	}

	stream := StreamClient{
		context: ctx,
		stream:  fStream,
	}

	stream.recv = func() (*ControlPlaneCommand, error) {
		p, err := stream.stream.ReadPacket()
		if err != nil {
			return nil, err
		}

		res := NewControlPlaneCommand()
		err = res.Decode((*p.Content).Bytes())
		if err != nil {
			return nil, err
		}
		if errors.Is(res.error, io.EOF) {
			return nil, io.EOF
		}

		return res, nil
	}

	stream.close = func() {
		stream.stream.Close()
	}
	stream.send = func(m *ControlPlaneResponse) error {
		p := packet.Get()

		m.Encode(p.Content)
		p.Metadata.ContentLength = uint32((*p.Content).Len())
		return stream.stream.WritePacket(p)
	}
	return &stream, nil
}

type StreamClient struct {
	context context.Context
	recv    func() (*ControlPlaneCommand, error)
	close   func()
	closed  *atomic.Bool

	stream *frisbee.Stream
	send   func(*ControlPlaneResponse) error
}

func (x *StreamClient) CloseChannel() <-chan struct{} {
	return x.stream.Conn().CloseChannel()
}

func (x *StreamClient) Recv() (*ControlPlaneCommand, error) {
	return x.recv()
}
func (x *StreamClient) Send(m *ControlPlaneResponse) error {
	return x.send(m)
}

func (x *StreamClient) CloseSend() error {
	return x.send(&ControlPlaneResponse{error: io.EOF})
}

func (x *StreamClient) CloseAndRecv() (*ControlPlaneCommand, error) {
	err := x.send(&ControlPlaneResponse{error: io.EOF})
	if err != nil {
		return nil, err
	}
	return x.recv()
}

type CloseError struct {
	err error
}

func NewCloseError(err error) CloseError {
	return CloseError{err: err}
}

func (e CloseError) Error() string {
	return e.err.Error()
}
